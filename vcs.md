Культура работы с системой контроля версий
==========================================

Культура внесения изменений в репозиторий так же важна, как и культура написания кода.
Они дополняют друг друга, и вместе входят в более объемлющее понятие _культура программирования_,
которое, впрочем, ими одними не ограничивается.

Грамотный код позволяет легко находить и исправлять ошибки, легко дорабатывать и изменять код,
добавлять функциональность и т.д.

А грамотная работа с системой контроля версий позволяет:

1. Всей команде быть в курсе происходящих в проекте дел, а также быстро входить в курс дел
   новоприбывающим участникам команды.
2. При обнаружении ошибки быстро находить и чинить участки кода, в которых эта ошибка произошла.
3. Экономить время программиста.
4. Повысить эффективность разработки.

Главные принципы
----------------

### Комит

*   Осмысленность

    Изменения, которые были внесены в репозиторий, объединены единым смыслом и преследуют строго
    определённую цель.

*   Неделимость

    Комит содержит ровно одно логическое изменение кода. Одно логическое изменение — это не
    изменение только одного файла или только одной строчки. Это значит, что, если в комментарии
    хочется написать "сделано то, сё, а ещё пятое и десятое", то, скорее всего, комит недостаточно
    декомпозирован, и его нужно разбить на несколько более мелких логических частей.

### Комментарий

*   Комментарий раскрывает смысл комита

    Важно, что описание должно говорить о смысле изменения, а не о конкретных действиях. Не нужно
    дублировать в комментарии ту информацию, которая уже заложена в сам комит. То есть писать в
    комментарии, что в комите изменены такой-то файл или такая-то функция — бессмысленно. Это можно
    понять, просмотрев разницу кода. Но нужно написать _зачем_ был изменён файл или функция.

    И да, слово "fix" не несёт смысловой нагрузки.

Стиль комментариев
------------------

1.  Язык

    Комментарии пишутся для того, чтобы их читать. Это средство общения между программистами.
    Каждый комментарий пишется только один раз, а читают его десятки или сотни раз.

    Писать комментарии к комитам нужно на том же языке, на котором программисты разговаривают на
    совещаниях.

2.  Длина описания
    1. Краткое описание должно быть кратким.
    2. После короткого описания следуют два перевода строки, а затем начинается подробное описание.

    Пример:

        refs #21 Ошибка при неявных преобразованиях

        При выполнении битовых операций могут произойти неочевидные на первый взгляд, но
        удовлетворяющие стандарту, неявные преобразования. Поэтому нужно вызвать явное
        преобразование к однобайтовому числу.

3.  Привязка к задаче

    Каждый комит отражает некое осмысленное изменение кода. Это осмысленное действие должно
    приближать автора комита к некой цели. Этой целью в данном случае является выполнение задачи.

    Если комит делается в рамках решения уже поставленной задачи, то нужно привязать его к этой
    задаче. Если задачи ещё нет, то её нужно поставить, даже если задача решается всего одним
    комитом.

    Такой подход позволяет по задаче быстро находить все комиты, которые к ней относятся, а по
    комиту — быстро находить задачу, в рамках которой он совершён.

4.  Служебная информация
   
    Дополнительную служебную информацию, которая не имеет ценности для человека, следует помещать в
    расширенное описание.
    Пример комментария, содержащего команду для автоматического создания обзора:

        refs #44 Приведение в порядок тестов итераторов и диапазонов

        Была путаница с терминологией, и тесты диапазонов оказались в тестах итераторов.
        Этот недочёт был исправлен. Теперь тесты итераторов лежат в итераторах, а тесты
        диапазонов — в диапазонах.
         
        +review @ivanov @petrov @sidorov

    Данное правило не относится, например, к привязке комита к задаче, потому что эта информация
    для человека как раз важна.

5.  Комментарий непуст

    Следует из остальных требований, но требует отдельного внимания.

Обзор кода
----------

Программист решает свою задачу, пишет или редактирует некоторый код, а затем выставляет результат
своей работы на обсуждение. Остальные участники команды рассматривают код и делают замечания или
задают вопросы.

По итогам обсуждения принимается решение о внесении обсуждённого участка кода в репозиторий или о
его переработке.

> Рекомендуется проводить обзор кода до того, как код попал в репозиторий. В этом случае в
> репозиторий попадает меньше ошибок и поддерживается общее качество дейстующего кода.

Правила обозрения кода:

1.  Исправления нуждаются в повторном обзоре

    Если по результатам обсуждения решено внести исправления в код, то мелкие исправления следует
    приклеить к комитам, к которым они относятся, а в случае крупных изменений (дизайна,
    архитектуры и т.п.) реорганизовать комиты так, чтобы, во-первых, в истории не осталось
    информации о старом, "плохом" варианте, а были только комиты с новым, "хорошим" вариантом кода,
    а во-вторых, чтобы каждый комит — как и всегда — соответствовал главным принципам.

    Такой подход позволит поддерживать историю проекта в максимально целостном состоянии. Например,
    если при обозрении в одном из комитов была найдена ошибка, то, если эту ошибку исправить
    отдельным комитом, получится, что в истории останется комит с этой ошибкой. А если исправление
    ошибки приклеить к комиту, в котором ошибка была обнаружена, то её как будто никогда и не было.
    Аналогично и с "плохой" архитектурой — её просто не останется в истории.

    Здесь, разумеется, речь идёт только о новом коде, который ещё не попал в основной репозиторий
    или ветку. Историю старого кода лучше не переписывать, это только навредит проекту.

    > **Примечание**
    >
    > Если система контроля версий не поддерживает изменение истории, то каждое логически
    > выделенное исправление нужно провести отдельным комитом, а потом все эти комиты снова
    > выставить на обсуждение.
    >
    >> **Важно**
    >>
    >> В этом случае не надо запихивать все изменения в один комит под названием "правки к ревью".
    >> Каждый комит, в том числе включающий "правки к ревью", должен удовлетворять главным
    >> принципам внесения правок в репозиторий: осмысленности и неделимости.

2.  Цикл исправлений-обсуждений повторяется до победного конца

    Каждое изменение кода — даже то, которое совершалось с целью исправления ошибок — может внести
    новые ошибки или неточности. Поэтому правки по итогам обсуждения снова обсуждаются. Если надо —
    вносятся новые правки, снова обсуждаются и т.д.

    Цикл продолжается до тех пор, пока обозреватели — участники обсуждения — не решат, что текущий
    результат достаточно хорош для того, чтобы находиться в репозитории.

Структура СКВ
-------------

1.  Не нужно хранить частные настройки в общем репозитории

    У каждого проекта есть система сборки. Это файлы, которые живут вместе с проектом и
    используются всеми разработчиками.

    Всё остальное — например, файлы настроек текстовых редакторов, IDE и прочих вещей, которыми
    пользуется какой-то конкретный разработчик, и которыми не обязаны пользоваться другие — не
    должно ни храниться в репозитории, ни даже упоминаться в нём (например, в .gitignore или
    svn:ignore).

    Такие файлы для проекта — мусор, потому что они не относятся ни к коду проекта, ни к настройкам
    сборки. Это вкусовщина, субъективные настройки, которые у разных программистов разные.

2.  Не нужно хранить в репозитории пустые папки

    Некоторые СКВ позволяют хранить в репозитории пустые папки. Это вредная практика, потому что
    такие папки обычно предназначены только для того, чтобы жёстко привязывать к ним пути в
    каких-либо (например, сборочных) скриптах. Это ломает гибкость системы.

3.  Не нужно комитить закомментированный код

    Иногда в репозитории оставляют закомментированный код под предлогом того, что "нужно видеть
    старый вариант", "он ещё может понадобиться" и т.п.

    Это попытка взять на себя работу СКВ.

    Так делать не нужно, потому что система контроля версий и существует для того, чтобы хранить и
    просматривать историю изменений, переключаться между этими изменениями и т.д.
    Закомментированный код никто не поддерживает, он быстро устаревает, и им в любом случае
    становится невозможно пользоваться. Он просто лежит мёртвым грузом и замусоривает исходники.

    Естественно, речь не идёт о коде, который является примером к использованию какой-либо
    сущности. Такой закомментированный код имеет право на существование, хотя для примеров лучше по
    возможности создавать отдельные файлы.

Автоматизация
-------------

В идеальном мире невыполнение хотя бы одного из требований к комиту или его комментарию приводит к
отклонению и переработке комита.

Всё, что можно доверить автоматике, например, непустоту или привязку к задаче, надо доверить
автоматике — комит-хукам. Но некоторые вещи (например, осмысленность) автоматически проверить
сложно, поэтому их придётся проверять живым людям на этапе приёмки (обзора или аналогов).
