Культура написания модульных тестов
===================================

Культура написания модульных тестов — это ещё одна составляющая понятия _культура
программирования_. Написание тестов, конечно, не гарантирует, что ПО будет качественным, но вот их
отсутствие — практически гарантирует некачественность.
Поэтому тесты нужно не просто писать, но нужно писать их правильно.

Правильно написанные модульные тесты:

1.  Добавляют уверенности в процессе разработки

    Крупные программные сущности складываются как по кирпичикам из более мелких сущностей. Если
    каждый кирпичик сам по себе работает хорошо и правильно, то возрастает и вероятность того, что
    собираемая из них сущность также будет работать правильно.

2.  Помогают понять, как устроена программная сущность, и как с ней обращаться

    Модульный тест — это, в том числе, и "активная документация". Эту "документацию" можно
    запустить и убедиться, что программная сущность соответствует требованиям, наложенным на неё.
    Таким образом, для программной сущности всегда есть актуальная документация и примеры по её
    использованию.

3.  Упрощают процесс переработки кода, затрагивающего программную сущность

    При грамотно написанных модульных тестах можно не бояться сломать сущность. Если в результате
    изменения кода сущность перестаёт удовлетворять требованиям, заложенным в "активную
    документацию", то об этом станет известно сразу же после запуска тестов. Более того, при
    грамотно написанных тестах будет сообщено, какое именно из требований перестало выполняться.
    Такое несоответствие будет легко найти и поправить.

4.  Гарантируют, что однажды найденная ошибка больше никогда не повторится

    Если в реализации программной сущности была выявлена ошибка, то грамотный разработчик сразу же
    формулирует свойство или особенность интерфейса этой сущности в виде утверждения,
    противоречащего сути возникшей ошибки, и добавляет это новое требование к тестам.

Проектирование модульных тестов
-------------------------------

Каждая достаточно сложная осмысленная изолированная программная сущность требует отдельной
проверки.

#### Общие требования

Модульные тесты программной сущности должны включать её:

1.  Определение

    Определение может состоять из нескольких компонент, и в этом случае каждая из таких компонент
    должна быть сформулирована в виде отдельного утверждения, а значит, должна быть выделена в
    отдельную проверку.

    С другой стороны, случается, что программная сущность является неотъемлемой частью другой
    программной сущности, и сформулировать отдельное определение сложно или невозможно.
    В этом случае нет смысла дублировать проверку определения.

2.  Свойства

    Свойства программной сущности — это то, что характеризует её саму по себе на концептуальном
    уровне. Поведение в определённых ситуациях, граничные условия и т.д.

    Свойств программной сущности может быть много. Каждое их них должно быть сформулировано в виде
    некоторого утверждения и выделено отдельную проверку.

3.  Особенности интерфейса

    Особенности интерфейса определяют, как может или должна использоваться в коде программная
    сущность. Это может быть наличие необходимых методов или полей у класса, возможность или
    невозможность его копирования, требования к формату входных и выходных данных функции,
    выбрасывание исключений в определённых ситуациях и т.п.

    Каждая особенность интерфейса также должна быть выделена в отдельную проверку.

> **Примечание**
>
> Для упрощения разработки имеет смысл заранее, до написания собственно кода разрабатываемой
> сущности, зафиксировать требования к ней в виде модульных тестов, и только затем приступать к
> программной реализации этой сущности.
>
> При таком подходе, когда программа скомпилируется и все тесты пройдут без ошибок, можно сказать,
> что задача решена.

#### Технические требования

Тесты должны быть:

1.  Быстрыми

    Программисты ленивы. Чем дольше выполняются тесты, тем реже их будут запускать. Идеальное время
    выполнения тестов — моментально.

2.  Автоматическими

    Программист может забыть запустить тесты. Поэтому процесс запуска модульных тестов желательно
    автоматизировать. Лучше всего встраивать выполнение тестов в сборку проекта. Запустить сборку
    он уж точно (ну, если не совсем угорелый) не забудет.

    Тогда, если тесты выполняются быстро, то они и не будут раздражать, и не дадут требованиям
    разойтись с суровой реальностью.

3.  Детерминированными

    Результат прохождения теста не должен меняться со временем. При любом количестве
    последовательных запусков каждая проверка должна выдавать один и тот же результат: либо всегда
    проходить, либо никогда не проходить.

    Не стоит использовать в тестах генераторы случайных чисел и другие подобные вещи.

4.  Независимыми

    Результаты прохождения тестов не должны зависеть от того, какое подмножество тестов
    запускается, и в каком порядке.

    Каждый тест либо всегда проваливается, либо всегда проходит.

#### Требования к коду

Код модульных тестов — это такой же код, как и любой другой. Это значит, что любой программист
(не только автор) должен иметь возможность понять этот код и, при необходимости, исправить.

Поэтому к коду тестов применяются те же самые стандарты качества, что и для любого другого кода. Но
есть и некоторые условия, специфичные для кода модульных тестов:

1.  Одно требование — один тест

    Если получилось, что для проверки одного и того же требования понадобилось написать несколько
    разных тестов, то либо требование недостаточно чётко сформулировано, либо тесты избыточны.

    Надо либо декомпозировать требование, разбив его на несколько более ясных требований, либо
    удалить лишние тесты.

2.  Один тест — одно требование

    Падающий тест должен однозначно указывать на требование, которое перестало выполняться. Поэтому
    нельзя проверять несколько требований в одном тесте.

    Если в упавшем тесте проверялись несколько требований, то программисту придётся производить
    какие-то дополнительные телодвижения, чтобы понять, что именно пошло не так.

3.  Название теста идентично формулировке требования

    Названия тестов — это связующее звено между миром абстрактных сущностей, существующем в
    воображении программиста, и программой, которая этот мир моделирует.

    С одной стороны, названия тестов нужны, чтобы программист, который хочет разобраться с некоей
    программной сущностью, мог понять, что она из себя представляет, какими свойствами обладает и
    как ей пользоваться (иначе говоря, какие на неё наложены требования).

    С другой стороны, если что-то сломалось, то именно названия тестов сообщают программисту о том,
    что конкретно пошло не так.

4.  Трёхчастное произведение

    Код каждого теста состоит из трёх частей:

    1. Подготовка исходных данных.
    2. Действие.
    3. Проверка результатов.

    Подготовка исходных данных и действие могут быть очень простыми или не выражены в коде явно.
    Тем не менее, они всегда есть.

    А проверка результатов не только всегда есть, но и всегда выражена явно, потому что это и есть
    индикатор прохождения теста.

5.  Ничего лишнего

    Ничто не должно отвлекать читателя теста от того, что этот тест непосредственно проверяет.

    Если подготовка исходных данных или проверка полученных результатов сложно читаются или
    занимают слишком много места, то нужно декомпозировать тест так же, как и обычную функцию —
    вынести всё лишнее в отдельные сущности, а в тесте оставить только суть.

6.  Необходимый контекст

    От читателя теста не должно быть скрыто то, что ему действительно важно знать.

    Правильно сформулированное требование (а значит, и название теста) содержит информацию об
    исходном состоянии окружающего мира до того, как на него подействовали исследуемой программной
    сущностью, а также информацию об ожидаемом результате этого взаимодействия.

    Вся эта информация — исходоное состояние и результат — должна быть явно выражена в коде теста.

7.  Строгое разграничение ответственности

    Программист несёт ответственность только за свою программную сущность.

    При написании теста предполагается, что всё остальное, кроме исследуемой сущности, работает
    правильно. В противном случае придётся проверять используемую библиотеку, компилятор или
    интерпретатор, операционную систему, аппаратуру и все известные человечеству законы физики.

--------

### Пример

Модульные тесты функции вычисления синуса ```my::sin```.

#### Формулировка требований

1.  Определение

    Синус угла прямоугольного треугольника — это отношение противолежащего катета к гипотенузе.

2.  Свойства
    1. Синус нуля равен нулю.
    2. Синус прямого угла равен единице.
    3. Синус — нечётная функция.
    4. Синус — периодическая функция с периодом 2π.

    и т.д.

3.  Особенности интерфейса
    1. Функция ```my::sin``` умеет вычисляться на этапе компиляции.
    2. Функция ```my::sin``` принимает на вход один аргумент — число с плавающей точкой, и
       возвращает тот же тип.
    3. Угол задаётся в радианах, а не в градусах.

    и т.п.

#### Написание кода тестов

Далее приводится сиплюсплюсоподобный псевдокод (_не пытайтесь повторить это дома!_) модульных
тестов, в котором каждое из вышеуказанных утверждений выделено в отдельную проверку:

```c++
test_suite(definition)
{
    test_case(sine_of_the_angle_of_a_right_triangle_is_equal_to_the_ratio_of_the_opposite_leg_to_the_hypotenuse)
    {
        auto triangle = right_triangle(3, 4, 5);
        auto angle = acute_angle(triangle);

        check(my::sin(angle) == opposite_leg(triangle) / hypotenuse(triangle));
    }
}

test_suite(properties)
{
    test_case(sine_of_zero_is_zero)
    {
        check(my::sin(0) == 0);
    }

    test_case(sine_of_a_right_angle_is_one)
    {
        check(my::sin(pi / 2) == 1);
    }

    test_case(sine_is_an_odd_function)
    {
        auto angles_in_all_quarters = {pi / 8, 2 * pi / 3, -pi / 4, 7 * pi / 6};
        for (auto x: angles_in_all_quarters)
        {
            check(my::sin(-x) == -my::sin(x));
        }
    }

    test_case(sine_is_a_periodic_function_with_period_2_pi)
    {
        auto angles_in_all_quarters = {pi / 8, 2 * pi / 3, -pi / 4, 7 * pi / 6};
        for (auto x: angles_in_all_quarters)
        {
            check(my::sin(x + 2 * pi) == my::sin(x));
            check(my::sin(x - 2 * pi) == my::sin(x));
        }
    }
}

test_suite(interface)
{
    test_case(my_sin_is_a_constexpr_function)
    {
        // Здесь при неудаче просто не скомпилируется.
        constexpr auto x = my::sin(pi);
    }

    test_case(my_sin_accepts_double_and_returns_double)
    {
        check(signature_is<double (double)>(&my::sin));
    }

    test_case(the_angle_is_specified_in_radians)
    {
        auto radians = pi / 4;
        auto degrees = to_degrees(radians);

        auto expected_value = 1 / sqrt(2);

        check(my::sin(radians) == expected_value);
        check(my::sin(degrees) != expected_value);
    }
}
```
